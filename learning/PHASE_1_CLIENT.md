# Phase 1 — Core Client Library

## Overview

Phase 1 built the gRPC client layer that communicates with MinKNOW. This involved:
- Connecting to MinKNOW's manager service over TLS
- Discovering devices and flow cell positions
- Fetching acquisition state and statistics
- Handling authentication tokens
- Implementing reconnection with exponential backoff

The client serves both the TUI and CLI, providing a clean abstraction over MinKNOW's protobuf APIs.

---

## Concepts

### gRPC and Protocol Buffers

**Protocol Buffers (protobuf)** is a language-neutral serialization format. You define message types in `.proto` files:

```protobuf
message Device {
    string id = 1;
    string name = 2;
    DeviceState state = 3;
}
```

Field numbers (1, 2, 3) are wire identifiers — they're what actually gets serialized, not field names. This enables schema evolution.

**gRPC** builds on protobuf to define services with RPC methods:

```protobuf
service ManagerService {
    rpc flow_cell_positions(FlowCellPositionsRequest) 
        returns (stream FlowCellPositionsResponse);
}
```

Key gRPC concepts:
- **Unary RPC**: Request → Response (like REST)
- **Server streaming**: Request → Stream of responses
- **Client streaming**: Stream of requests → Response
- **Bidirectional streaming**: Stream ↔ Stream

MinKNOW uses server streaming extensively — `flow_cell_positions` returns a stream that updates when devices change.

### tonic and prost

**prost** generates Rust types from `.proto` files. Each message becomes a struct:

```rust
// Generated by prost
pub struct Device {
    pub id: String,
    pub name: String,
    pub state: i32,  // Enums become i32
}
```

**tonic** generates gRPC client/server code and provides the runtime:

```rust
// Generated service client
pub struct ManagerServiceClient<T> {
    inner: tonic::client::Grpc<T>,
}

impl ManagerServiceClient<Channel> {
    pub async fn flow_cell_positions(
        &mut self,
        request: impl tonic::IntoRequest<FlowCellPositionsRequest>,
    ) -> Result<Response<Streaming<FlowCellPositionsResponse>>, Status>
}
```

The `Channel` type represents a connection to a gRPC server. It handles HTTP/2, TLS, and connection pooling.

### Async Rust with Tokio

gRPC is inherently async — you're waiting on network I/O. Rust's async model:

```rust
// This function can be suspended while waiting
async fn fetch_data() -> Result<Data, Error> {
    let response = client.get_data().await?;  // Suspend here
    Ok(response.into_inner())
}
```

**Key rules:**
1. `async fn` returns a `Future` — nothing runs until you `.await` it
2. `.await` can only be called inside `async` contexts
3. Futures are lazy — they don't start until polled

**Tokio** is the async runtime that actually executes futures:

```rust
#[tokio::main]
async fn main() {
    // Now we can use .await
    let result = fetch_data().await;
}
```

### Streams

gRPC streaming maps to Rust's `Stream` trait — an async iterator:

```rust
use futures::StreamExt;

let mut stream = client.flow_cell_positions(request).await?.into_inner();

while let Some(response) = stream.message().await? {
    for position in response.positions {
        println!("Found: {}", position.name);
    }
}
```

`stream.message().await` returns `Option<Result<T, Status>>`:
- `Some(Ok(msg))` — Got a message
- `Some(Err(status))` — Stream error
- `None` — Stream ended

### TLS with Custom CA

MinKNOW uses TLS with a self-signed certificate. The CA cert lives at:
```
/var/lib/minknow/data/rpc-certs/minknow/ca.crt
```

tonic's TLS configuration:

```rust
use tonic::transport::{Certificate, Channel, ClientTlsConfig};

let ca_cert = std::fs::read_to_string("/path/to/ca.crt")?;

let tls_config = ClientTlsConfig::new()
    .ca_certificate(Certificate::from_pem(&ca_cert))
    .domain_name("localhost");  // Must match cert's CN

let channel = Channel::from_shared("https://localhost:9501")?
    .tls_config(tls_config)?
    .connect()
    .await?;
```

---

## Patterns

### Domain Types vs Proto Types

**Problem:** Generated proto types are awkward — enums are `i32`, optional fields are `Option<T>`, naming follows protobuf conventions.

**Solution:** Define clean domain types and convert:

```rust
// Our domain type
pub struct Position {
    pub name: String,
    pub device_id: String,
    pub state: PositionState,
    pub grpc_port: u32,
}

// Proto type → Domain type
impl Position {
    pub fn from_proto(proto: crate::proto::FlowCellPosition) -> Self {
        Self {
            name: proto.name,
            device_id: proto.device_id,
            state: PositionState::from_proto(proto.state),
            grpc_port: proto.rpc_ports
                .and_then(|p| p.secure)
                .unwrap_or(0) as u32,
        }
    }
}
```

**Benefits:**
- Clean API for consumers
- Proto changes don't leak through your API
- Can add derived traits, methods, validation

### Unified Error Type

**Problem:** Different operations fail differently — connection errors, gRPC status codes, parsing errors. Callers need consistent error handling.

**Solution:** Single error enum with context:

```rust
pub enum ClientError {
    Connection { endpoint: String, source: Box<dyn Error + Send + Sync> },
    Grpc { method: String, status: tonic::Status },
    Protocol { message: String },
    NotFound { resource: String, id: String },
    Timeout { operation: String },
    Disconnected,
    Auth { message: String },
}

impl ClientError {
    pub fn is_retriable(&self) -> bool {
        match self {
            ClientError::Connection { .. } => true,
            ClientError::Grpc { status, .. } => matches!(
                status.code(),
                Code::Unavailable | Code::DeadlineExceeded | Code::Aborted
            ),
            ClientError::Timeout { .. } => true,
            ClientError::Disconnected => true,
            _ => false,
        }
    }
}
```

**Key insight:** `is_retriable()` centralizes retry logic. Connection errors and certain gRPC codes (Unavailable, DeadlineExceeded) are worth retrying; NotFound is not.

### Interceptors for Cross-Cutting Concerns

**Problem:** Every request to position services needs an auth token header.

**Solution:** tonic interceptors modify requests before they're sent:

```rust
#[derive(Clone)]
struct AuthInterceptor {
    token: Option<Arc<str>>,
}

impl Interceptor for AuthInterceptor {
    fn call(&mut self, mut request: Request<()>) -> Result<Request<()>, Status> {
        if let Some(ref token) = self.token {
            let value = token.parse().map_err(|_| 
                Status::internal("Invalid auth token")
            )?;
            request.metadata_mut().insert("local-auth", value);
        }
        Ok(request)
    }
}

// Apply to client
let client = AcquisitionServiceClient::with_interceptor(channel, interceptor);
```

**When to use:** Authentication, tracing/logging, request IDs, metrics.

### Exponential Backoff with Jitter

**Problem:** If MinKNOW restarts, all clients reconnect simultaneously (thundering herd).

**Solution:** Exponential backoff with random jitter:

```rust
pub struct ReconnectPolicy {
    pub initial_delay: Duration,    // 1s
    pub max_delay: Duration,        // 30s
    pub multiplier: f64,            // 2.0
    pub jitter_fraction: f64,       // 0.1 (±10%)
}

impl ReconnectPolicy {
    fn delay_for_attempt(&self, attempt: u32) -> Duration {
        // Exponential: 1s, 2s, 4s, 8s, 16s, 30s (capped)
        let base = self.initial_delay.as_secs_f64() 
            * self.multiplier.powi(attempt as i32);
        let capped = base.min(self.max_delay.as_secs_f64());
        
        // Jitter: ±10% randomness
        let jitter_range = capped * self.jitter_fraction;
        let jitter = rand::rng().random_range(-jitter_range..jitter_range);
        
        Duration::from_secs_f64((capped + jitter).max(0.0))
    }
}
```

**Why jitter matters:** Without it, 100 clients all retry at exactly 1s, 2s, 4s... With ±10% jitter, retries spread across 0.9-1.1s, 1.8-2.2s, etc.

---

## Implementation Walkthrough

### Connection Flow

```
1. Client::connect("localhost", 9501)
   │
   ├─ Read CA cert from /var/lib/minknow/data/rpc-certs/minknow/ca.crt
   ├─ Configure TLS with ca_certificate + domain_name("localhost")
   ├─ Create Channel with connect_timeout(5s) + timeout(30s)
   ├─ Connect to https://localhost:9501
   ├─ Create ManagerServiceClient
   ├─ Fetch auth token path via local_authentication_token_path()
   ├─ Read and parse JSON token file
   └─ Return Client { manager, auth_token }

2. client.list_positions()
   │
   ├─ Call manager.flow_cell_positions() → Stream
   ├─ Collect all positions from stream
   └─ Convert proto types → domain types

3. client.connect_position(position)
   │
   ├─ Get position's gRPC port
   ├─ Create channel to https://localhost:{port}
   ├─ Create AuthInterceptor with token
   ├─ Create AcquisitionServiceClient with interceptor
   ├─ Create StatisticsServiceClient with interceptor
   └─ Return PositionClient
```

### Auth Token Discovery

MinKNOW's local auth is a two-step process:

1. **Get token path:** Call `local_authentication_token_path()` RPC (no auth required)
2. **Read token file:** JSON at that path contains `{"token": "uuid", "expires": "timestamp"}`

```rust
async fn fetch_auth_token(manager: &mut ManagerServiceClient<Channel>) 
    -> Result<Option<Arc<str>>, ClientError> 
{
    let response = manager
        .local_authentication_token_path(LocalAuthenticationTokenPathRequest {})
        .await?
        .into_inner();

    if response.path.is_empty() {
        return Ok(None);  // Guest mode enabled
    }

    let content = std::fs::read_to_string(&response.path)?;
    let token_data: serde_json::Value = serde_json::from_str(&content)?;
    let token = token_data.get("token").and_then(|v| v.as_str())
        .ok_or_else(|| ClientError::Auth { 
            message: "Missing 'token' field".into() 
        })?;

    Ok(Some(Arc::from(token)))
}
```

**Note:** Token expires and rotates. For long-running connections, you'd need to re-read periodically. For our CLI commands, single-read is sufficient.

---

## Gotchas & Lessons Learned

### 1. MinKNOW Requires Local Auth

**Symptom:** `get_acquisition_info: No authorisation metadata supplied`

**Cause:** MinKNOW's position services require a `local-auth` header even for localhost connections (unless guest mode is fully enabled).

**Solution:** Fetch token path from manager, read token, add via interceptor.

### 2. Proto Enums Are i32

**Symptom:** Type mismatch — expected enum, got integer.

**Cause:** prost represents protobuf enums as `i32` for forward compatibility.

**Solution:** Use `EnumType::try_from(value)` or match against constants:

```rust
match MinknowStatus::try_from(response.status) {
    Ok(MinknowStatus::Ready) => RunState::Idle,
    Ok(MinknowStatus::Processing) => RunState::Running,
    _ => RunState::Unknown,
}
```

### 3. Streaming RPCs Return Immediately

**Symptom:** `flow_cell_positions()` returns instantly, but there's no data.

**Cause:** The `await` on a streaming RPC just establishes the stream — data comes later via `stream.message().await`.

**Solution:** Always loop over stream messages:

```rust
let mut stream = client.flow_cell_positions(request).await?.into_inner();
while let Some(response) = stream.message().await? {
    // Process response
}
```

### 4. TLS domain_name Must Match Certificate

**Symptom:** TLS handshake failure.

**Cause:** MinKNOW's cert is issued for "localhost", but we might connect via IP.

**Solution:** Always use `domain_name("localhost")` in TLS config, regardless of actual host.

### 5. Blocking I/O in Async Context

**Symptom:** Application hangs or becomes unresponsive.

**Cause:** `std::fs::read_to_string()` blocks the async runtime thread.

**Reality:** For small files read once at startup, blocking is acceptable. For hot paths, use `tokio::fs` or `spawn_blocking`.

---

## Key Takeaways

1. **Separate proto types from domain types** — Generated code is a transport detail, not your API.

2. **Unified error types simplify handling** — One enum, one `is_retriable()` check, consistent display.

3. **Interceptors are powerful** — Auth, logging, metrics all belong in interceptors, not scattered through code.

4. **gRPC streams are async iterators** — Treat them like any other Rust iterator, just with `.await`.

5. **Exponential backoff needs jitter** — Without randomness, retries synchronize and create thundering herds.

6. **TLS requires the right CA** — Self-signed certs need explicit CA configuration; system roots won't work.

7. **MinKNOW auth is file-based** — Token lives in a JSON file; path comes from an RPC.

---

## Resources

### Official Documentation
- [tonic docs](https://docs.rs/tonic) — gRPC for Rust
- [prost docs](https://docs.rs/prost) — Protocol buffer implementation
- [tokio docs](https://docs.rs/tokio) — Async runtime
- [Protocol Buffers Language Guide](https://protobuf.dev/programming-guides/proto3/)
- [gRPC Core Concepts](https://grpc.io/docs/what-is-grpc/core-concepts/)

### Rust Async
- [Async Book](https://rust-lang.github.io/async-book/) — Official async Rust guide
- [Tokio Tutorial](https://tokio.rs/tokio/tutorial) — Practical async patterns

### Related Projects
- [tonic examples](https://github.com/hyperium/tonic/tree/master/examples) — Official examples
- [MinKNOW API](https://github.com/nanoporetech/minknow_api) — Proto definitions we're wrapping

### Error Handling
- [Error Handling in Rust](https://blog.burntsushi.net/rust-error-handling/) — Classic article on error design
- [thiserror docs](https://docs.rs/thiserror) — Derive macro for error types
